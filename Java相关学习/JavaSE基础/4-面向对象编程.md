## 一、类与对象

###1.类与对象

1.什么是类？
​		对现实世界中，具有共同特性的某一类事物的抽象的描述，在Java中使用一个类来描述一类事物
 2.什么是对象？
​		对象是类的一个具体的个体，是类的一个实例
​	    类是对象的设计模板，对象是类的实例
3.二者的区别
​		类是抽象的
​		对象是具体的，实际存在的，也称为 实体或实例
 4.二者的关系
​		类是由对象总结或抽取出来的一个概念。 是对象的所属类型
​		对象是通过类创建出来的具体的实体

### 2. 内存结构分析
栈（stack）：一般存放基本数据类型（局部变量；生命周期只限于方法被放在栈中的这段期间；即方法调用至执行完毕为止）

堆（heap）：存放对象，对象本身只会存于堆上。堆又称为可被垃圾回收的堆

​	Java在新建一个对象时，在堆空间会创建一个足以存放该对象所有实例变量的空间。即实例变量存放在于对象所属的堆空间上。

方法区：常量池（常量，比如字符串），类的加载信息（类名、包名、属性的描述信息、方法的描述信息）。

## 二、类的内部成员

### 1.属性（成员变量，实例变量）

声明在类内，方法外

声明的格式：权限修饰符  数据类型 属性名；

​						权限修饰符  数据类型  属性名=初始值；//显示初始化

> 如果在声明类时没有显式（手动）给属性赋初始值，那么在创建对象后，这个属性有默认的初始值
> 	byte,short,int,long   初始值为0
> 	float,double  初始值为0.0
> 	boolean  初始值为false
> 	char 初始值为\u0000
> 	引用数据类型（类、接口、数组）  初始值为null

实力变量也可以是一个对对象的引用，即引用与对象都是在堆上的

实例变量的寿命与对象相同，

### 2.方法

####2.1 定义：

```
权限修饰符 返回值类型 方法名（形参列表）{
	方法体;
	return 返回值;
}
```

####2.2 调用细节：

①同一个类中的方法调用：直接调用即可
②跨类中的方法调用：需要通过对象名调用
③方法可调用同类方法，但不能嵌套

####2.3 成员方法传参机制：

**基本数据类型的传参机制：**

形参的变化不会影响到实参，因为基本数据类型传参只是相当于拷贝了一个备份到形参。

```java
public class MethodParameter01 {
	//编写一个 main 方法
	public static void main(String[] args) {
		int a = 10;
		int b = 20;
		//创建 AA 对象 名字 obj
		AA obj = new AA();
		obj.swap(a, b); //调用 swap
		System.out.println("main 方法 a=" + a + " b=" + b);//a=10 b=20
	}
}
class AA {
	public void swap(int a,int b){
		System.out.println("\na 和 b 交换前的值\na=" + a + "\tb=" + b);//a=10 b=20
		//完成了 a 和 b 的交换
		int tmp = a;
		a = b;
		b = tmp;
		System.out.println("\na 和 b 交换后的值\na=" + a + "\tb=" + b);//a=20 b=10
	}
}
```

**引用数据类型的传参机制**：

引用数据类型的传参相当于传递了一个地址号（引用）到形参，形参的改变影响实参

```java

```
####2.4 可变参数：
定义：
`访问修饰符 返回类型 方法名(数据类型... 形参名) {}`

本质是数组，所以传入的实参也可以是数组

①==一个形参列表中只能出现一个可变参数==

②可变参数可以和普通类型的参数一起放在形参列表，==**但必须保证可变参数在最后。**==

####2.5 方法的重载

方法的重载：Java允许多个同名方法的存在，但是形参列表要不一致

一同：方法名要相同；

两不同：形参列表中的形参顺序或个数不同，参数名无要求。

#### 2.6 方法的重写

方法的重写：就是子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么我们就说子类的这个方法覆盖了父类的方法。

**要求：**

1. 子类的方法的形参列表、方法名称要和父类的完全一样

2. 子类方法的返回类型和父类方法的返回类型一样，或者是父类返回类型的子类

   eg:父类 返回类型是Object,子类方法返回类型是String

3. 子类方法不能缩小父类方法的访问权限。

#### 2.7 方法的重写和重载的区别

1. 发生范围：重写是在有继承关系的父子类内，重载是在本类内
2. 方法名：重写和重载都要求方法名相同
3. 形参列表：重载的话要求参数列表中个数或顺序有一个不一样，重写要求子类必须和父类完全相同
4. 权限修饰符：重载无要求，重写的话要求子类的修饰符不能小于父类的
5. 返回值类型：重载无要求，重写的话要求子类和父类一致或者是父类返回类型的子类



### 3.构造器

####3.1 定义：

```java
权限修饰符 方法名(形参列表){
    方法体;
}
```

####3.2 作用：

完成对属性的初始化，不是创建。

####3.3 细节：

1. 方法名与类名相同
2. 没有返回值
3. 在创建对象时，系统自动调用该类的构造器完成对对象的初始化
4. 如果没有自定义的构造器，系统会自动给类生成一个默认无参的构造器
5. 一旦定义了自己的构造器，默认的构造器就被覆盖了，就不能使用默认的无参构造器，除非显示的定义一下

### 4.代码块

####4.1 定义：

​	属于类中的成员。类似方法，但是和方法不同，没有方法名和返回值，没有参数，只有方法体。而且不用通过类或对象显式地调用，而是加载类时或创建对象时隐式调用。

#### 4.2 分类

1. 静态代码块

   定义：随着==类==的加载而执行一次，且只会执行一次。

   ```
   static{
   	
   }
   ```

   作用：为静态属性赋值

2. 非静态代码块（普通代码块）

   定义：每创建一个对象就执行

   ```
   {
   	
   }
   ```

   作用：当多个构造器中重复的代码，可以提取到构造块中。

**静态代码块只能直接调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员**

####4.3调用顺序

==优先级一样的，按定义顺序执行==

**1-前提：无继承关系，创建一个对象时，在一个类调用顺序是：**

①静态代码块和静态属性初始化掉调用的优先级一样，如果有多个静态代码块和静态属性，则按他们定义的顺序调用

②同上，普通代码块和普通属性初始化

③调用构造方法

**2-前提：有继承关系，创建一个子类对象时，调用顺序是：**

①父类的静态代码块和静态属性初始化

②子类的静态代码块和静态属性初始化

③父类的普通代码块和普通属性初始化

④父类的构造器

⑤子类的普通代码块和普通属性初始化

⑥子类的构造器

####4.4 类被加载的情况

①创建对象实例时（new）

②创建子类对象实例时，父类也会被加载

③使用类的静态成员时（静态属性，静态方法）



###5.内部类

####5.1 定义
​		一个类的内部又完整地嵌套了另一个类结构，被嵌套地类称为内部类

**特点：**可以直接访问私有属性，并且可以体现类与类之的包含关系。

```java
class Outer{//外部类
	class Inner{//内部类
		
	}
}
class Other{//外部其他类
	
}
```



####5.2 分类

定义在外部类局部位置上（比如方法内）：

①局部内部类（有类名）

==②匿名内部类（没有类名）==

定义在外部类的成员位置上：

③成员内部类（没用static修饰）

④静态内部类（使用static修饰）



####5.3 内部类的使用

##### 5.3.1 局部内部类

1. 定义在外部类的局部位置（方法中）

   ```
   权限修饰符 外部类{
   	权限修饰符 返回值类型 方法名（形参列表）{
   		class 内部类名{
   			//局部内部类
   		}
   	}
   }
   ```

2. 不能添加权限修饰符，因为局部变量是不能使用修饰符的。但是可以使用final修饰

3. 可以直接访问外部类的所有成员，包括私有的

4. 作用域：仅仅在定义它的方法或代码块中

5. 外部类访问局部内部类的方式：**创建对象，再访问。**

6. 外部其他类不能访问局部内部类，因为局部内部类地位是一个局部变量

7. 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问。

##### 5.3.1 匿名内部类（没有类名）

1. 定义在外部类的局部位置（方法中） $1

   ```
   权限修饰符 外部类{
   	权限修饰符 返回值类型 方法名（形参列表）{
   		new 类或接口(参数列表){
   			//类体
   		};
   	}
   }
   ```

2. 可以直接访问外部类的所有成员，包含私有的

3. 不能添加访问修饰符，因为它的地位就是一个局部变量

4. 作用域：仅仅在定义它的方法或代码块中

5. 匿名内部类访问外部类成员的方式：直接访问

6. 外部其他类不能访问匿名内部类，因为匿名内部类地位是一个局部变量

7. 如果外部类和匿名内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问。

##### 5.3.1 成员内部类（非static修饰的）

1. 定义：定义在外部类的成员位置

   ```
   权限修饰符 class 外部类{
   	权限修饰符 class 内部类{
   		
   	}
   }
   ```

2. 可以直接访问外部类的所有成员，包括私有的

3. 可以添加任意访问修饰符，因为其地位就是一个成员

4. 作用域：和外部类的其他成员一样，为整个类体

5. 成员内部类访问外部类成员（比如属性）的方式：直接访问

6. 外部类访问成员内部类的访问方式：创建对象，再访问

7. 如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问。

##### 5.3.1 静态内部类（static修饰的）

1. 定义：定义在外部类的成员位置，并且有static修饰

   ```
   权限修饰符 class 外部类{
   	权限修饰符 static class 内部类{
   		
   	}
   }
   ```

2. 可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员



## 三、关键字的使用

### 1.this

this表示当前对象
**用法:**
①this.属性 ：当成员变量与局部变量重名时使用
②this.方法
③this()或this(实参列表)：表示调用本类的其他构造器，必须在首行，避免循环调用。

### 2.super

super表示父类的引用，**只能在构造器中使用。**
**用法**
①super.属性：当子类的属性与父类的属性重名时
②super.方法：调用父类的方法实现
	但不能访问父类的私有private属性和方法
③super()或super(实参列表）：**在继承时，调用父类的构造器，只能出现且只能出现在构造器的第一句**

### 3.static

static表示静态的，用static修饰变量和方法的时候将其称为类变量和类方法。

####3.1 类变量

static变量是同一个类所有对象共享的

static类变量在类加载的时候就生成了（即使没有创建对象，只要类加载了就可以使用类变量）

>类变量也叫做静态变量或静态属性

**定义语法：**

`权限修饰符 static 数据类型 变量名;`

**如何访问类变量：**

`类名.类变量名  或   对象名.类变量名`

#### 3.2 类方法

当方法中不涉及到任何和对象相关的成员，则可以设计成静态方法，提高开发效率。

**定义语法：**

`权限修饰符 static 数据类型 方法名(){};`

**如何访问类方法：**

`类名.类方法名()`

==静态方法只能访问静态的成员；非静态方法可以访问静态成员和非静态成员==

### 4. final

可以修饰类、属性、方法、局部变量。

使用场景：

①当不希望类被继承是，可以用final修饰

②当不希望父类某个方法被子类覆盖/重写，可以利用final关键字修饰

③当不希望类的某个属性的值或某个局部变量被修改，可以用final修饰

1. final修饰的属性叫做常量，全部字母大写，多单词有_隔开

2. final修饰的属性在定义时，**必须赋初值**，并且以后不能再修改

   可以在以下位置初始化：

   ①定义时

   ②构造器

   ③代码块

3. 如果final修饰的属性是静态的，则初始化的位置只能是

   ①在定义时

   ③在静态代码块，不能在构造器中赋值

   ​	**因为：**静态成员是随着类的加载而执行的，而构造器是在类对象实例化的时候才能执行，既不能满足final修饰的属性在定义时必须赋值的添加

6. 一般来说，如果一个类已经是final类了就没有必要再将其方法修饰成final方法

7. final不能修饰构造器（构造方法）

8. final和static往往搭配使用效率更高，不会导致类加载

   ```java
   class Demo{
       public final static int i;
       static{
           i=16;
       }
       public static void main(String[] args){
           System.out.println(Demo.i);//可以输出i,且不会加载类
       }
   }
   ```
### 5. instanceof

1. 表示某个对象是否是本类或本类的子类的对象

   eg:a instanceof Type

   返回true a是type的对象 或  a是type的子类的对象

2. **用于判断对象的==运行类型==是否为xx类型或xx类型的子类型**



### 6. 抽象类 （abstract）

####6.1**定义：**

当父类的某些方法，需要声明，但是又不确定如何实现时，可以将其声明为抽象方法，这个类就是抽象类。

**用abstract关键字来修饰一个类时，这个类就叫做抽象类。**

`权限修饰符 abstract class类名{} `

**用abstract关键字来修饰一个方法时，这个方法就是抽象方法**

`权限修饰符  abstract 返回类型 方法名(参数列表);//没有方法体`

####6.2 细节和注意事项

1. 抽象方法没有方法体

2. 当一个类中存在抽象方法，需要将该类声明为abstract类

3. 一般来说，抽象类会被继承，有其子类来实现抽象方法

4. ==抽象类不能被实例化==

5. abstract只能修饰类和方法，不能修饰属性和其他的

6. 抽象类本质仍然是类，可以有任意成员

7. 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类。**抽象类可以不用全部实现父类抽象类的所有方法**

8. **抽象方法不能使用private、final、static来修饰，因为这些关键字都是与重写相违背的**

   eg:abstract final class A{} 就不能被编译通过，因为final修饰的类不能被继承。

9. 抽象类可以包含抽象方法，也可以没有抽象方法

### 7.接口 （interface）

#### 7.1 定义

就是给出一些没有实现的方法封装到一起，到某个类要使用的时候在根据具体情况把这些方法写出来。

#### 7.2 语法

```java
//声明和实现
interface 接口名{
    //属性
    //抽象方法
}
class 类名 implements 接口{
    //属性
    //方法
    //必须实现的接口的抽象方法
}
```

**接口是更加抽象的抽象类，抽象类里有的方法可以有方法体，接口里的所有方法都没有方法体**

#### 7.3 细节和注意实现

1. **接口不能被实例化**

2. 接口中所有的方法是public方法，接口中抽象方法可以不用abstract修饰

   `void aaa(); 实际上是public abstract void aaa();`

3. 一个普通类实现接口，就必须将该类接口的所有方法都实现

4. 抽象类实现接口，可以不用全部实现接口的方法

5. 一个类同时可以实现多个接口，接口名之间用逗号隔开

6. 接口中的属性，只能是final的，而且是public、static、final修饰符

   `int a=1;实际上是public static final int a=1;(必须初始化)`

7. 接口中属性的访问形式：接口名.属性名

8. 接口不能继承其他的类，但是可以继承多个别的接口

9. 接口的修饰符只能是public和默认的，因为接口要被实现。

10. 在有继承关系的子父类中，如果父类实现了接口的方法，则子类会继承该方法。即子类会继承父类对于接口的实现。

#### 7.4 接口的作用

1. 解决了Java的单继承
2. 多个不相关的类，可能具有共同的行为特征，这样的行为特征，就可以提取成一个接口
3. 若以接口取代具体的子类或抽象的父类作为参数或返回类型，则可以传入任何有实现该接口的东西。

#### 7.5接口和继承的区别

1. 解决的问题不同：①继承的价值主要在于解决代码的复用性和可维护性

   ​							   ②接口的价值主要在于设计好各种规范（方法）让其他类去实现这些方法，即更加灵活。

2. 接口比继承更加灵活：①继承是满足is-a的关系

   ​									   ②接口只需满足like-a的关系

3. 当子类继承了父类，就自动的拥有父类的功能

4. 如果子类需要扩展的功能，可以通过实现接口的方法扩展，可以理解，实现接口时对Java单继承机制的一种补充。

--------------------------------

接口的多态：接口类型可以指向实现该类接口的类的对象实例

-----------------------



## 四、单例设计模式

### 1.定义 

所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法

### 2.分类

1. 饿汉式

   在类加载时候就创建了对象实例

2. 懒汉式

   防止饿汉式可能造成创建了对象但是没有使用导致的资源浪费，所以引出懒汉式

   

**二者的区别：饿汉式是类加载的时候就创建了对象，懒汉式是在使用时才创建。**



### 3.饿汉式实现步骤

1.构造器私有化

2.在类的内部创建私有的static对象

3.向外暴露一个静态的公共方法，用于返回对象

```java
package com.zmm.homework_;

/**
 * @author zmm
 */
public class SingleTon01 {
    public static void main(String[] args) {
//        System.out.println(GirlFriend.getInstance());
        GirlFriend instance=GirlFriend.getInstance();
        GirlFriend instance2=GirlFriend.getInstance();
        System.out.println(instance);
        System.out.println(instance2);
    }
}
class GirlFriend{
    private String name;

    private  GirlFriend(String name) {
        this.name = name;
    }

    private static GirlFriend g1=new GirlFriend("小蕊");

    public static GirlFriend getInstance(){
        return g1;
    }

    @Override
    public String toString() {
        return "GirlFriend{" +
                "name='" + name + '\'' +
                '}';
    }
}
```



###4.懒汉式实现步骤

1. 将构造器私有化
2. 定义一个static静态属性对象
3. 提供一个public的static方法，只有当用户使用这个方法时，才返回cat对象。如果再次调用也会返回上次创建的cat对象

```java
package com.zmm.homework_;

/**
 * @author zmm
 */
public class SingleTon02 {
    public static void main(String[] args) {
        Cat c1=Cat.getInstance();
        System.out.println(c1);
    }
}
class Cat{
    private String name;
    private static Cat cat;

    private Cat(String name){
        this.name=name;
    }

    public static Cat getInstance(){
        if(cat==null){
            cat=new Cat("咪咪");
        }
        return cat;
    }

    @Override
    public String toString() {
        return "Cat{" +
                "name='" + name + '\'' +
                '}';
    }
}
```



## 五、面向对象三大特征

面向对象有三大特征：封装、继承、多态

### 1.封装

#### 1.1 定义

就是把抽象出的属性和方法封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作（方法），才能对数据进行操作。

#### 1.2 权限修饰符

|           | 同类 | 同包 | 子类 | 不同包 |
| :-------: | :--: | :--: | :--: | :----: |
|  public   |  ✓   |  ✓   |  ✓   |   ✓    |
| protected |  ✓   |  ✓   |  ✓   |        |
|   默认    |  ✓   |  ✓   |      |        |
|  private  |  ✓   |      |      |        |

#### 1.3 封装的实现

1. 在属性的前面加private修饰
2. 提供公共的get/set方法



### 2.继承(extends)

#### 2.1 继承的基本语法

```java
class 子类 extends 父类{}
```

1. 子类会自动拥有父类定义的属性和方法
2. 父类又叫做超类、基类
3. 子类又叫派生类

#### 2.2 继承的好处

1. 代码的复用性提高了
2. 代码的扩展性和维护性提高了

#### 2.3 继承的细节

1. 子类继承了父类==所有的==属性和方法（除构造器），非私有的属性和方法可以在子类中直接访问，但是私有属性不能直接访问，要通过父类提供的公共方法去访问

> 子类继承父类之后，在官方文档的解释中，子类无法继承父类私有的属性和方法，但是可以通过get/set方法调用。至于构造器是不能被继承的，但是在实例化子类的时候会调用父类的构造方法。

1. 子类必须调用父类的构造器，完成父类的初始化。子类构造器中默认有一个隐藏的super
2. 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用**super(对应的参数)**指定父类哪个构造器完成对父类的初始化工作，否则，编译不通过。
3. super( )和this( )都只能放在构造器第一行，因此这两个方法不能共存在一个构造器。
4. java所有类都是Object类的子类，Object类是所有类的基类
5. 父类构造器的调用不限于直接父类，将一直往上追溯到Object类（顶级父类）
6. 子类最多只能继承一个父类，Java中是单继承机制



### 3.多态

#### 3.1 定义

方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的

#### 3.2 多态的具体体现

1. 方法的多态

   重写和重载

2. 对象的多态

   1. 一个对象的编译类型和运行类型可以不一致
   2. 编译类型在定义对象时就确定了，不能改变，运行类型是可以改变的
   3. ==**编译看左边，运行看右边**==

**多态的前提：两个对象（类）存在继承关系**

#### 3.3多态向上转型

**本质：**父类的引用指向子类的对象

**语法：**父类类型 引用名=new 子类类型( );

**特点：**编译类型看左边，运行类型看右边

1. 可以调用父类中的所有成员（需遵守访问权限）
2. **不能调用子类中特有的成员**
3. 最终运行效果看子类的具体实现（运行看右边）

#### 3.4多态向下转型

**语法：**子类类型 引用名=（子类类型）父类引用;

1. 只能强转父类的引用，不能强转父类的对象（就算换了个身份，他还是他）
2. 要求父类的引用必须指向的是当前目标类型的对象（不能把狗也说成猫）
3. 当向下转型后，可以调用子类类型中所有成员

#### 3.5 动态绑定机制

调用对象方法时，还是要看运行类型，如果子类无则到父类中去找

调用属性时，没有动态绑定机制，哪里声明就用哪里的

#### 3.6 多态的应用

多态数组

数组的定义类型为父类类型，里面保存的实际元素类型为子类类型

eg:Person[] persons=new Person[5];

​	用instanceof来判断属于哪个，然后向下转型

多态参数

方法定义的形参类型为父类类型，实参类型允许为子类类型